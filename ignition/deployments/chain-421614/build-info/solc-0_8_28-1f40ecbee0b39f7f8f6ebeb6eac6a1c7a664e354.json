{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-1f40ecbee0b39f7f8f6ebeb6eac6a1c7a664e354",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PrivateERC20.sol": "project/contracts/PrivateERC20.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/IPoco.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IexecLibOrders_v5} from \"../libraries/IexecLibOrders_v5.sol\";\n\n/**\n * @title IPoco\n * @notice Interface for the iExec Poco contract\n * @dev Used to call matchOrders directly on Arbitrum\n */\ninterface IPoco {\n    /**\n     * @notice Get the RLC token address\n     * @return The address of the RLC token\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Deposit RLC tokens to get sRLC for a target address\n     * @param amount Amount of RLC to deposit\n     * @param target Address to receive the sRLC\n     * @return success True if deposit succeeded\n     */\n    function depositFor(uint256 amount, address target) external returns (bool success);\n\n    /**\n     * @notice Pre-sign a request order to avoid requiring signature during matchOrders\n     * @param _requestorderoperation The request order operation containing the order and SIGN operation\n     */\n    function manageRequestOrder(\n        IexecLibOrders_v5.RequestOrderOperation calldata _requestorderoperation\n    ) external;\n\n    /**\n     * @notice Match orders to create a deal on the iExec protocol\n     * @param _apporder The app order\n     * @param _datasetorder The dataset order\n     * @param _workerpoolorder The workerpool order\n     * @param _requestorder The request order\n     * @return dealId The ID of the created deal\n     */\n    function matchOrders(\n        IexecLibOrders_v5.AppOrder calldata _apporder,\n        IexecLibOrders_v5.DatasetOrder calldata _datasetorder,\n        IexecLibOrders_v5.WorkerpoolOrder calldata _workerpoolorder,\n        IexecLibOrders_v5.RequestOrder calldata _requestorder\n    ) external returns (bytes32 dealId);\n}\n\n"
      },
      "project/contracts/interfaces/IPocoOApp.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IPocoOApp\n * @notice Interface for the PocoOApp LayerZero router\n * @dev This interface is used to route cross-chain calls to the iExec PoCo contract on Arbitrum\n * \n * The PocoOApp contract acts as a bridge between chains using LayerZero:\n * - On non-Arbitrum chains: Acts as a Router, forwarding calls to Arbitrum\n * - On Arbitrum: Acts as a Receiver, executing calls on the PoCo contract\n */\ninterface IPocoOApp {\n    /**\n     * @notice Routes a function call to the PoCo contract on Arbitrum via LayerZero\n     * @dev This function should be called with sufficient native token value to cover LayerZero fees\n     * \n     * @param targetFunction The function selector to call on the PoCo contract (e.g., 0x156194d4 for matchOrders)\n     * @param payload The encoded function arguments (abi.encode of the function parameters)\n     * @param refundAddress The address to refund any excess LayerZero fees\n     * @param options LayerZero adapter parameters for gas settings and execution options\n     * @return nonce The nonce of the cross-chain LayerZero message\n     */\n    function routeCall(\n        bytes4 targetFunction,\n        bytes calldata payload,\n        address refundAddress,\n        bytes calldata options\n    ) external payable returns (uint64 nonce);\n\n    /**\n     * @notice Quote the LayerZero fee for routing a call to Arbitrum\n     * @dev Use this to estimate the required msg.value for routeCall\n     * \n     * @param targetFunction The function selector (for gas estimation)\n     * @param payload The encoded function call data\n     * @param options LayerZero adapter parameters\n     * @param payInLzToken Whether to return fee in ZRO token (typically false)\n     * @return fee The MessagingFee struct containing nativeFee and lzTokenFee\n     */\n    function quoteCall(\n        bytes4 targetFunction,\n        bytes calldata payload,\n        bytes calldata options,\n        bool payInLzToken\n    ) external view returns (MessagingFee memory fee);\n\n    /**\n     * @notice MessagingFee structure from LayerZero\n     * @dev Returned by quoteCall to indicate required fees\n     */\n    struct MessagingFee {\n        uint256 nativeFee;  // Fee in native gas token (ETH, etc.)\n        uint256 lzTokenFee; // Fee in LayerZero token (if applicable)\n    }\n}\n\n"
      },
      "project/contracts/interfaces/IPrivateERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IexecLibOrders_v5} from \"../libraries/IexecLibOrders_v5.sol\";\n\n/**\n * @title IPrivateERC20\n * @notice Interface for the PrivateERC20 token with encrypted balances\n * @dev ERC20-like token that uses iExec TEE for privacy-preserving transfers\n */\ninterface IPrivateERC20 {\n    // ============================================\n    // EVENTS\n    // ============================================\n\n    /**\n     * @notice Emitted when tokens are minted to an address\n     * @param to The address receiving the minted tokens\n     * @param encryptedAmount The encrypted amount of tokens minted\n     */\n    event Mint(address indexed to, bytes encryptedAmount);\n\n    /**\n     * @notice Emitted when an account's encrypted balance is updated\n     * @param account The account whose balance was updated\n     * @param newEncryptedBalance The new encrypted balance\n     */\n    event BalanceUpdate(address indexed account, bytes newEncryptedBalance);\n\n    /**\n     * @notice Emitted when a transfer request is initiated\n     * @param from The sender's address\n     * @param to The recipient's address\n     * @param encryptedAmount The encrypted amount to transfer\n     * @param dealId The deal ID returned from matchOrders\n     */\n    event TransferRequested(\n        address indexed from,\n        address indexed to,\n        bytes encryptedAmount,\n        bytes32 dealId\n    );\n\n    /**\n     * @notice Emitted when pre-signed orders are stored\n     * @param setter The address that stored the orders (owner)\n     */\n    event OrdersStored(address indexed setter);\n\n    // ============================================\n    // EXTERNAL FUNCTIONS\n    // ============================================\n\n    /**\n     * @notice Store pre-signed orders for iExec matchOrders\n     * @dev These orders should be signed off-chain by the respective owners\n     * @param _appOrder Pre-signed app order from app owner\n     * @param _workerpoolOrder Pre-signed workerpool order from workerpool owner\n     * @param _datasetOrder Dataset order (use empty order with dataset=address(0) if no dataset)\n     */\n    function storeOrders(\n        IexecLibOrders_v5.AppOrder calldata _appOrder,\n        IexecLibOrders_v5.WorkerpoolOrder calldata _workerpoolOrder,\n        IexecLibOrders_v5.DatasetOrder calldata _datasetOrder\n    ) external;\n\n    /**\n     * @notice Update PocoOApp router address\n     * @param _pocoOAppRouter New router address\n     */\n    function setPocoOAppRouter(address _pocoOAppRouter) external;\n\n    /**\n     * @notice Update Poco contract address\n     * @param _pocoAddress New Poco address\n     */\n    function setPocoAddress(address _pocoAddress) external;\n\n    /**\n     * @notice Update LayerZero options\n     * @param _lzOptions New LZ options\n     */\n    function setLzOptions(bytes calldata _lzOptions) external;\n\n    /**\n     * @notice Mint tokens with encrypted amount\n     * @param to Address to mint tokens to\n     * @param encryptedAmount Encrypted amount to mint\n     */\n    function mint(address to, bytes calldata encryptedAmount) external;\n\n    /**\n     * @notice Request a transfer operation to be processed by TEE\n     * @dev Requires payment for LayerZero fees (msg.value)\n     * @param to Recipient address\n     * @param encryptedAmount Encrypted amount to transfer\n     */\n    function transfer(address to, bytes calldata encryptedAmount) external payable;\n\n    /**\n     * @notice Update encrypted balances for sender and receiver\n     * @dev This function should only be called by the iExec TEE enclave\n     * @param sender Sender address\n     * @param receiver Receiver address\n     * @param senderNewBalance New encrypted balance for sender\n     * @param receiverNewBalance New encrypted balance for receiver\n     */\n    function updateBalance(\n        address sender,\n        address receiver,\n        bytes calldata senderNewBalance,\n        bytes calldata receiverNewBalance\n    ) external;\n\n    /**\n     * @notice Get encrypted balance of an account\n     * @param account Account to query\n     * @return The encrypted balance\n     */\n    function balanceOf(address account) external view returns (bytes memory);\n}\n\n"
      },
      "project/contracts/libraries/IexecLibOrders_v5.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IexecLibOrders_v5\n * @notice Library containing iExec order structures for PoCo v5\n * @dev These structures are used for matchOrders calls on the iExec protocol\n */\nlibrary IexecLibOrders_v5 {\n    /**\n     * @notice App order structure\n     * @dev Signed by the app owner to authorize app usage\n     */\n    struct AppOrder {\n        address app;                    // Address of the app contract\n        uint256 appprice;              // Price per task in nRLC\n        uint256 volume;                // Number of tasks authorized\n        bytes32 tag;                   // TEE tag requirements\n        address datasetrestrict;       // Restrict to specific dataset (address(0) = no restriction)\n        address workerpoolrestrict;    // Restrict to specific workerpool (address(0) = no restriction)\n        address requesterrestrict;     // Restrict to specific requester (address(0) = no restriction)\n        bytes32 salt;                  // Unique salt for order\n        bytes sign;                    // Signature of the order\n    }\n\n    /**\n     * @notice Dataset order structure\n     * @dev Signed by the dataset owner to authorize dataset usage\n     */\n    struct DatasetOrder {\n        address dataset;               // Address of the dataset contract\n        uint256 datasetprice;         // Price per task in nRLC\n        uint256 volume;               // Number of tasks authorized\n        bytes32 tag;                  // TEE tag requirements\n        address apprestrict;          // Restrict to specific app (address(0) = no restriction)\n        address workerpoolrestrict;   // Restrict to specific workerpool (address(0) = no restriction)\n        address requesterrestrict;    // Restrict to specific requester (address(0) = no restriction)\n        bytes32 salt;                 // Unique salt for order\n        bytes sign;                   // Signature of the order\n    }\n\n    /**\n     * @notice Workerpool order structure\n     * @dev Signed by the workerpool owner to authorize task execution\n     */\n    struct WorkerpoolOrder {\n        address workerpool;           // Address of the workerpool contract\n        uint256 workerpoolprice;     // Price per task in nRLC\n        uint256 volume;              // Number of tasks authorized\n        bytes32 tag;                 // TEE tag requirements\n        uint256 category;            // Task category (compute resources)\n        uint256 trust;               // Trust level required\n        address apprestrict;         // Restrict to specific app (address(0) = no restriction)\n        address datasetrestrict;     // Restrict to specific dataset (address(0) = no restriction)\n        address requesterrestrict;   // Restrict to specific requester (address(0) = no restriction)\n        bytes32 salt;                // Unique salt for order\n        bytes sign;                  // Signature of the order\n    }\n\n    /**\n     * @notice Request order structure\n     * @dev Created by the requester to request task execution\n     */\n    struct RequestOrder {\n        address app;                 // Address of the app to execute\n        uint256 appmaxprice;        // Maximum price willing to pay for app\n        address dataset;            // Address of the dataset (address(0) = no dataset)\n        uint256 datasetmaxprice;    // Maximum price willing to pay for dataset\n        address workerpool;         // Address of the workerpool (address(0) = no restriction)\n        uint256 workerpoolmaxprice; // Maximum price willing to pay for workerpool\n        address requester;          // Address of the requester\n        uint256 volume;             // Number of tasks to execute\n        bytes32 tag;                // TEE tag requirements\n        uint256 category;           // Task category\n        uint256 trust;              // Trust level required\n        address beneficiary;        // Address to receive results\n        address callback;           // Address to callback after execution\n        string params;              // JSON parameters for the task\n        bytes32 salt;               // Unique salt for order\n        bytes sign;                 // Signature of the order\n    }\n\n    /**\n     * @notice Order operation enum for manageRequestOrder\n     * @dev Used to specify the type of operation to perform on an order\n     */\n    enum OrderOperationEnum {\n        SIGN,      // Pre-sign the order (no signature required in matchOrders)\n        CLOSE      // Close/cancel the order\n    }\n\n    /**\n     * @notice Request order operation structure\n     * @dev Used with manageRequestOrder to pre-sign orders\n     */\n    struct RequestOrderOperation {\n        RequestOrder order;           // The request order to manage\n        OrderOperationEnum operation; // Operation to perform (SIGN or CLOSE)\n        bytes sign;                   // Signature (can be empty for contract calls)\n    }\n}\n\n"
      },
      "project/contracts/PrivateERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IexecLibOrders_v5} from \"./libraries/IexecLibOrders_v5.sol\";\nimport {IPocoOApp} from \"./interfaces/IPocoOApp.sol\";\nimport {IPrivateERC20} from \"./interfaces/IPrivateERC20.sol\";\nimport {IPoco} from \"./interfaces/IPoco.sol\";\n\n/**\n * @title PrivateERC20\n * @dev ERC20-like token with encrypted balances for privacy\n * Designed to work with iExec TEE for off-chain decryption\n * All state is encrypted with a single public key\n */\ncontract PrivateERC20 is IPrivateERC20 {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    \n    // Public key used to encrypt all balances (stored as bytes for flexibility)\n    bytes public encryptionPublicKey;\n    \n    // Encrypted balances mapping: address => encrypted balance\n    mapping(address => bytes) public encryptedBalances;\n    \n    // Pre-signed orders for iExec matchOrders\n    IexecLibOrders_v5.AppOrder public appOrder;\n    IexecLibOrders_v5.WorkerpoolOrder public workerpoolOrder;\n    IexecLibOrders_v5.DatasetOrder public datasetOrder; // Will be empty but needed for matchOrders\n    \n    // PocoOApp router address (for cross-chain calls)\n    address public pocoOAppRouter;\n    // Poco contract address (for direct calls on Arbitrum)\n    address public pocoAddress;\n    // Flag to determine if we're on Arbitrum (direct call) or need to route\n    bool public isArbitrum;\n    // LayerZero options for cross-chain calls\n    bytes public lzOptions;\n    \n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        bytes memory _encryptionPublicKey,\n        address _pocoOAppRouter,\n        address _pocoAddress,\n        bool _isArbitrum,\n        bytes memory _lzOptions\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        encryptionPublicKey = _encryptionPublicKey;\n        totalSupply = 0;\n        pocoOAppRouter = _pocoOAppRouter;\n        pocoAddress = _pocoAddress;\n        isArbitrum = _isArbitrum;\n        lzOptions = _lzOptions;\n    }\n    \n    /**\n     * @dev Store pre-signed orders for iExec matchOrders\n     * \n     * These orders should be signed off-chain by the respective owners:\n     * - AppOrder: Signed by the app owner (for the TEE computation app)\n     * - WorkerpoolOrder: Signed by the workerpool owner (for TEE execution)\n     * - DatasetOrder: Can be empty (dataset = address(0)) if no dataset is required\n     * \n     * The RequestOrder will be created on-chain dynamically in the transfer() function\n     * with the requester set to msg.sender and params containing transfer details.\n     * \n     * Important: Ensure all orders are compatible:\n     * - Same category and trust level\n     * - Compatible tags (TEE requirements)\n     * - Matching restrictions\n     * - Valid signatures in the 'sign' field\n     * \n     * @param _appOrder Pre-signed app order from app owner\n     * @param _workerpoolOrder Pre-signed workerpool order from workerpool owner\n     * @param _datasetOrder Dataset order (use empty order with dataset=address(0) if no dataset)\n     */\n    function storeOrders(\n        IexecLibOrders_v5.AppOrder calldata _appOrder,\n        IexecLibOrders_v5.WorkerpoolOrder calldata _workerpoolOrder,\n        IexecLibOrders_v5.DatasetOrder calldata _datasetOrder\n    ) external {\n        require(_appOrder.app != address(0), \"App address cannot be zero\");\n        require(_workerpoolOrder.workerpool != address(0), \"Workerpool address cannot be zero\");\n        require(_appOrder.volume > 0, \"App order volume must be > 0\");\n        require(_workerpoolOrder.volume > 0, \"Workerpool order volume must be > 0\");\n        \n        appOrder = _appOrder;\n        workerpoolOrder = _workerpoolOrder;\n        datasetOrder = _datasetOrder;\n        \n        emit OrdersStored(msg.sender);\n    }\n    \n    /**\n     * @dev Update PocoOApp router address\n     * @param _pocoOAppRouter New router address\n     */\n    function setPocoOAppRouter(address _pocoOAppRouter) external {\n        require(_pocoOAppRouter != address(0), \"Invalid router address\");\n        pocoOAppRouter = _pocoOAppRouter;\n    }\n    \n    /**\n     * @dev Update Poco contract address\n     * @param _pocoAddress New Poco address\n     */\n    function setPocoAddress(address _pocoAddress) external {\n        require(_pocoAddress != address(0), \"Invalid Poco address\");\n        pocoAddress = _pocoAddress;\n    }\n    \n    /**\n     * @dev Update LayerZero options\n     * @param _lzOptions New LZ options\n     */\n    function setLzOptions(bytes calldata _lzOptions) external {\n        lzOptions = _lzOptions;\n    }\n    \n    /**\n     * @dev Mint tokens with encrypted amount\n     * @param to Address to mint tokens to\n     * @param encryptedAmount Encrypted amount to mint\n     */\n    function mint(address to, bytes calldata encryptedAmount) external {\n        require(to != address(0), \"Cannot mint to zero address\");\n        require(encryptedAmount.length > 0, \"Invalid encrypted amount\");\n        \n        // Store the encrypted balance (encrypted with the contract's public key)\n        encryptedBalances[to] = encryptedAmount;\n        \n        emit Mint(to, encryptedAmount);\n    }\n    \n    /**\n     * @dev Request a transfer operation to be processed by TEE\n     * @param to Recipient address\n     * @param encryptedAmount Encrypted amount to transfer\n     */\n    function transfer(address to, bytes calldata encryptedAmount) external payable {\n        require(to != address(0), \"Cannot transfer to zero address\");\n        require(to != msg.sender, \"Cannot transfer to self\");\n        require(encryptedAmount.length > 0, \"Invalid encrypted amount\");\n        require(appOrder.app != address(0), \"Orders not configured\");\n        \n        // Create request order on-chain\n        IexecLibOrders_v5.RequestOrder memory requestOrder = IexecLibOrders_v5.RequestOrder({\n            app: appOrder.app,\n            appmaxprice: appOrder.appprice,\n            dataset: address(0), // No dataset\n            datasetmaxprice: 0,\n            workerpool: workerpoolOrder.workerpool,\n            workerpoolmaxprice: workerpoolOrder.workerpoolprice,\n            requester: address(this),\n            volume: 1, // Single task\n            tag: appOrder.tag,\n            category: workerpoolOrder.category,\n            trust: workerpoolOrder.trust,\n            beneficiary: address(this), // Callback to this contract\n            callback: address(this),\n            params: _buildTransferParams(msg.sender, to, encryptedAmount),\n            salt: keccak256(abi.encodePacked(msg.sender, to, block.timestamp)),\n            sign: \"\" // Empty - will be pre-signed via manageRequestOrder\n        });\n        \n        // Call matchOrders via PocoOApp router\n        bytes32 dealId = _callMatchOrders(requestOrder);\n        emit TransferRequested(msg.sender, to, encryptedAmount,dealId);\n    }\n    \n    /**\n     * @dev Build params string for transfer request\n     * @param from Sender address\n     * @param to Recipient address\n     * @param encryptedAmount Encrypted amount\n     * @return Space-separated params string: encrypteddata sender recipient\n     */\n    function _buildTransferParams(\n        address from,\n        address to,\n        bytes calldata encryptedAmount\n    ) private pure returns (string memory) {\n        // Build space-separated args for the iExec app\n        // Format: encrypteddata sender recipient\n        // Using string.concat for cleaner and safer concatenation\n        return string.concat(\n            _bytesToHexString(encryptedAmount),\n            ' ',\n            _addressToString(from),\n            ' ',\n            _addressToString(to)\n        );\n    }\n    \n    /**\n     * @dev Call matchOrders via PocoOApp router or directly\n     * @param requestOrder The request order\n     * @return dealId The deal ID returned from matchOrders\n     */\n    function _callMatchOrders(\n        IexecLibOrders_v5.RequestOrder memory requestOrder\n    ) private returns (bytes32) {\n        if (isArbitrum) {\n            // On Arbitrum, call Poco directly\n            require(pocoAddress != address(0), \"Poco address not set\");\n            \n            // Pre-sign the request order using manageRequestOrder\n            // This allows the contract to be the requester without needing an off-chain signature\n            IexecLibOrders_v5.RequestOrderOperation memory requestOrderOperation = \n                IexecLibOrders_v5.RequestOrderOperation({\n                    order: requestOrder,\n                    operation: IexecLibOrders_v5.OrderOperationEnum.SIGN,\n                    sign: new bytes(0)\n                });\n            \n            IPoco(pocoAddress).manageRequestOrder(requestOrderOperation);\n            \n            // Now call matchOrders with the pre-signed request order\n            bytes32 dealId = IPoco(pocoAddress).matchOrders(\n                appOrder,\n                datasetOrder,\n                workerpoolOrder,\n                requestOrder\n            );\n            \n            return dealId;\n        } else {\n            // Route the call through PocoOApp to Arbitrum via LayerZero\n            require(pocoOAppRouter != address(0), \"PocoOApp router not set\");\n            \n            // The matchOrders function selector from IexecPoco1Facet\n            bytes4 functionSelector = 0x156194d4; // matchOrders selector\n            \n            // Encode the full function call with all parameters\n            bytes memory payload = abi.encode(\n                appOrder,\n                datasetOrder,\n                workerpoolOrder,\n                requestOrder\n            );\n            \n            // Forward the call via LayerZero\n            uint64 nonce = IPocoOApp(pocoOAppRouter).routeCall{value: msg.value}(\n                functionSelector,\n                payload,\n                msg.sender, // Refund address for excess LayerZero fees\n                lzOptions\n            );\n            \n            // Note: We can't get the real dealId directly from cross-chain call\n            // The actual dealId will be available in the CrossChainDealCreated event on Arbitrum\n            // For tracking purposes, we return a deterministic placeholder based on nonce\n            return keccak256(abi.encodePacked(msg.sender, block.timestamp, nonce));\n        }\n    }\n    \n    /**\n     * @dev Helper function to convert address to string\n     */\n    function _addressToString(address _addr) private pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(_addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint256 i = 0; i < 20; i++) {\n            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n    \n    /**\n     * @dev Helper function to convert bytes to hex string\n     */\n    function _bytesToHexString(bytes calldata _bytes) private pure returns (string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(2 + _bytes.length * 2);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint256 i = 0; i < _bytes.length; i++) {\n            str[2 + i * 2] = alphabet[uint8(_bytes[i] >> 4)];\n            str[3 + i * 2] = alphabet[uint8(_bytes[i] & 0x0f)];\n        }\n        return string(str);\n    }\n    \n    /**\n     * @dev Update encrypted balances for sender and receiver\n     * This function should only be called by the iExec TEE enclave\n     * after off-chain decryption and computation of transfer\n     * All amounts are encrypted with the contract's public key\n     * @param sender Sender address\n     * @param receiver Receiver address\n     * @param senderNewBalance New encrypted balance for sender\n     * @param receiverNewBalance New encrypted balance for receiver\n     */\n    function updateBalance(\n        address sender,\n        address receiver,\n        bytes calldata senderNewBalance,\n        bytes calldata receiverNewBalance\n    ) external {\n        require(sender != address(0), \"Invalid sender\");\n        require(receiver != address(0), \"Invalid receiver\");\n        require(senderNewBalance.length > 0, \"Invalid sender balance\");\n        require(receiverNewBalance.length > 0, \"Invalid receiver balance\");\n        \n        encryptedBalances[sender] = senderNewBalance;\n        encryptedBalances[receiver] = receiverNewBalance;\n        \n        emit BalanceUpdate(sender, senderNewBalance);\n        emit BalanceUpdate(receiver, receiverNewBalance);\n    }\n    \n    /**\n     * @dev Get encrypted balance of an account\n     * @param account Account to query\n     * @return Encrypted balance\n     */\n    function balanceOf(address account) external view returns (bytes memory) {\n        return encryptedBalances[account];\n    }\n}\n"
      }
    }
  }
}